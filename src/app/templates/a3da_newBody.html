<!DOCTYPE html>
{# 
	This is a Jinja2 template for an html page
	These lines are comments and are removed when the template is rendered. 
#}
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Blog of Blake Senftner</title>
  <link rel="stylesheet" href="/static/index.css">

  <style>
    div#mainContent {
	  box-sizing: border-box;
	  font-family: Helvetica, Arial, sans-serif;
	  font-size: 16px;
	  height: 50%;
	  margin: 0px;
	  position: relative;
	}

    .ctrlRow {
        width: 100%;
        display: flex;
        flex-direction: row;
        justify-content: left;
        align-items: center;
    }

    .ctrlRowLeft {
        width: 50%;
        margin-right: 10px;
    }

    .ctrlRowLeft .slidercaption {
        width: 130px;
    }

    .ctrlRowRight {
        width: 50%;
    }

    .ctrlRowRight .slidercaption {
        width: 130px;
    }

    .ctrlRowRight .button {
        justify-content: center;
        display: flex;
        width: 70%;
        margin-left: 15%;
    }

    #view_ctrls {
        width: 100%;
        display: flex;
        flex-direction: row;
        justify-content: left;
        align-items: center;
    }

    .slidercontainer {
        width: 100%;
        display: flex;
        flex-direction: row;
        justify-content: left;
        align-items: left;
    }

    .slidercaption {
        display: inline;
        font-weight: bold;
        width: 100px;
        margin-left: 10px;
        margin-right: 10px;
    }
      
    .slider {
        -webkit-appearance: none;
        flex-grow: 4;
        height: 25px;
        background: #d3d3d3;
        outline: none;
        opacity: 0.7;
        -webkit-transition: .2s;
        transition: opacity .2s;
    }
      
    .slider:hover {
        opacity: 1;
    }
      
    .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 25px;
        height: 25px;
        background: #04AA6D;
        cursor: pointer;
    }
      
    .slider::-moz-range-thumb {
        width: 25px;
        height: 25px;
        background: #04AA6D;
        cursor: pointer;
    }

    #view_ctrls .button {
        min-width: 170px;
    }

    #view_ctrls .slidercaption {
        min-width: 110px;
    }

  </style>

  <!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
  {
    "imports": {
      "three": "/static/three/build/three.module.js"
    }
  }
</script>

</head>
<body>
	<div class="grid">
		{% include 'common_header.html' %}

		{# the left sidebar #}
		{% include 'common_lsidebar.html' %}

		{# the main content area #}
		<main>
			<div id="mainContent"></div>
            <div id="view_ctrls">
                <a href="#" class="button" onclick="viewAtLoad()">Load View</a>
                <a href="#" class="button" onclick="viewFace()">Face View</a>
                <a href="#" class="button" onclick="viewFull45()">Full Body 45</a>
                <a href="#" class="button" onclick="viewMid45()">Mid Body View 45</a>
                <div class="slidercontainer">
                    <div class="slidercaption">Camera Lens:</div>
                    <input type="range" min="20" max="120" value="45" class="slider" id="cam_fov" oninput="camFOVChanged()">
                </div>
            </div>
            <div class="ctrlRow">
                <div class="ctrlRowLeft">
                    <h4>Ethnicity:</h4>
                    <div class="slidercontainer">
                        <div class="slidercaption">Asian:</div>
                        <input type="range" min="0" max="100" value="0" class="slider" id="sldr_asian" oninput="ethnicityChangedAsian()">
                    </div>

                    <div class="slidercontainer">
                        <div class="slidercaption">African:</div>
                        <input type="range" min="0" max="100" value="0" class="slider" id="sldr_african" oninput="ethnicityChangedAfrican()">
                    </div>
                        
                    <div class="slidercontainer">
                        <div class="slidercaption">Caucasian:</div>
                        <input type="range" min="0" max="100" value="100" class="slider" id="sldr_caucasian" oninput="ethnicityChangedCaucasian()">
                    </div>
                </div>
                <div class="ctrlRowRight">
                    <h4>Body Shape:</h4>
                    <div class="slidercontainer">
                        <div class="slidercaption">Thin 2 Heavy:</div>
                        <input type="range" min="0" max="200" value="0" class="slider" id="sldr_thin2Heavy" oninput="thin2HeavyChanged()">
                    </div>

                    <div class="slidercontainer">
                        <div class="slidercaption">Muscularity:</div>
                        <input type="range" min="0" max="300" value="0" class="slider" id="sldr_muscularity" oninput="muscularityChanged()">
                    </div>
                </div>
            </div>

            <div class="ctrlRow">
                <div class="ctrlRowLeft">
                    <h4>Face Shape:</h4>

                    <div class="slidercontainer">
                        <div class="slidercaption">Jaw In/Out:</div>
                        <input type="range" min="0" max="100" value="50" class="slider" id="sldr_jawInOut" oninput="jawInOutChanged()">
                    </div>

                    <div class="slidercontainer">
                        <div class="slidercaption">Square Jaw:</div>
                        <input type="range" min="0" max="100" value="0" class="slider" id="sldr_squareJaw" oninput="squareJawChanged()">
                    </div>
                        
                    <div class="slidercontainer">
                        <div class="slidercaption">Chin Cleft:</div>
                        <input type="range" min="0" max="100" value="0" class="slider" id="sldr_chinCleft" oninput="chinCleftChanged()">
                    </div>

                    <div class="slidercontainer">
                        <div class="slidercaption">Chin In/Out:</div>
                        <input type="range" min="0" max="100" value="50" class="slider" id="sldr_chinInOut" oninput="chinInOutChanged()">
                    </div>

                    <div class="slidercontainer">
                        <div class="slidercaption">Mouth In/Out:</div>
                        <input type="range" min="0" max="100" value="50" class="slider" id="sldr_mouthInOut" oninput="mouthInOutChanged()">
                    </div>
                        
                    <div class="slidercontainer">
                        <div class="slidercaption">Mouth Width:</div>
                        <input type="range" min="0" max="100" value="50" class="slider" id="sldr_mouthWidth" oninput="mouthWidthChanged()">
                    </div>

                    <div class="slidercontainer">
                        <div class="slidercaption">Gaunt:</div>
                        <input type="range" min="0" max="100" value="0" class="slider" id="sldr_gaunt" oninput="gauntChanged()">
                    </div>

                    <div class="slidercontainer">
                        <div class="slidercaption">Double Chin:</div>
                        <input type="range" min="0" max="100" value="0" class="slider" id="sldr_doubleChin" oninput="doubleChinChanged()">
                    </div>

                </div>
                <div class="ctrlRowRight">
                    <h4>&nbsp;</h4>

                    <div class="slidercontainer">
                        <div class="slidercaption">Cheek Bones:</div>
                        <input type="range" min="0" max="100" value="0" class="slider" id="sldr_cheekBones" oninput="cheekBonesChanged()">
                    </div>
                        
                    <div class="slidercontainer">
                        <div class="slidercaption">Nose Size:</div>
                        <input type="range" min="0" max="100" value="50" class="slider" id="sldr_noseSize" oninput="noseSizeChanged()">
                    </div>

                    <div class="slidercontainer">
                        <div class="slidercaption">Nose Top In/Out:</div>
                        <input type="range" min="0" max="100" value="50" class="slider" id="sldr_noseTopInOut" oninput="noseTopInOutChanged()">
                    </div>

                    <div class="slidercontainer">
                        <div class="slidercaption">Nose Mid In/Out:</div>
                        <input type="range" min="0" max="100" value="50" class="slider" id="sldr_noseMidInOut" oninput="noseMidInOutChanged()">
                    </div>
                        
                    <div class="slidercontainer">
                        <div class="slidercaption">Nose Tip:</div>
                        <input type="range" min="0" max="100" value="0" class="slider" id="sldr_noseTip" oninput="noseTipChanged()">
                    </div>

                    <div class="slidercontainer">
                        <div class="slidercaption">Brow In/Out:</div>
                        <input type="range" min="0" max="100" value="50" class="slider" id="sldr_browInOut" oninput="browInOutChanged()">
                    </div>

                    <div class="slidercontainer">
                        <div class="slidercaption">Forehead Top:</div>
                        <input type="range" min="0" max="100" value="50" class="slider" id="sldr_foreheadTop" oninput="foreheadTopChanged()">
                    </div>

                    <div>
                        <a href="#" class="button" onclick="resetFaceShape()">Reset Face Shape To Neutral</a>
                    </div>
                </div>
                </div>
            </div>

		</main>

		{# the right sidebar #}
		<aside>
			<div id="aside">
				<a href="#" class="button" onclick="Login()">Login</a>
				<br/>
				<a href="#" class="button" onclick="Register()">Register</a>
			</div>
		</aside>
  
	<footer>
		{{ frags[0].footer | safe }} 
	</footer>
	</div>

    <script>
		function UserContact() { window.location.href = "/Contact"; }

		function Contact() { window.location.href = "/precontact"; }

		function Login() { window.location.href = "/login"; }

		function Register() { window.location.href = "/register"; }

		function UserSettings() { window.location.href = "/Settings"; }
	</script>
	
    <script>
        
		let gCamera, gScene, gParentObj, gCamCtrls, gProgressCube;
        let gMeshObjs = [];

		const gNewAvatarSceneInfo = { 
            'inited': false,
			'cam': {
				'pos': { 'x': 0, 'y': 40, 'z': 50 },
				'target': { 'x': 0, 'y': 20, 'z': 0 },
				'helper': false,
			},
			'obj': {
				'url': 'static/a3da/avatar2022.glb',
				'scale': 20,
			},
            'race': {
                'asian': 0.0, 'african': 0.0, 'caucasian': 1.0
            }
		};


        function camFOVChanged() {
            if (typeof gCamera !== 'undefined') {
                let camFovSldr = document.getElementById("cam_fov");
                gCamera.fov = parseFloat(camFovSldr.value);
                gCamera.updateProjectionMatrix();
                console.log( "camera FOV is " + camFovSldr.value);
            }
        }



        // position camera where the scene loads:
        function viewAtLoad() {
            if (typeof gCamCtrls !== 'undefined') {
                let si = gNewAvatarSceneInfo;
                gCamera.position.set( si.cam.pos.x, si.cam.pos.y, si.cam.pos.z );
                //
                document.getElementById("cam_fov").value = "45";
                camFOVChanged();
                //
                gCamCtrls.target.set( si.cam.target.x, si.cam.target.y, si.cam.target.z );
			    gCamCtrls.update();
            }
        }

        // position camera to view the face:
        function viewFace() {
            if (typeof gCamCtrls !== 'undefined') {
                gCamera.position.set( 0, 33, 8 );
                gCamCtrls.target.set( 0, 33.34, -1.3478 );
			    gCamCtrls.update();
            }
        }

        // position camera:
        function viewFull45() {
            if (typeof gCamCtrls !== 'undefined') {
                gCamera.position.set( 32, 32.275, 41.568 );
                gCamCtrls.target.set( 0.15, 18.554, 0.3714 );
			    gCamCtrls.update();
            }
        }

        // position camera:
        function viewMid45() {
            if (typeof gCamCtrls !== 'undefined') {
                gCamera.position.set( 19.4734, 32.3731, 20.0688 );
                gCamCtrls.target.set( -0.45, 25.875, -2.2695 );
			    gCamCtrls.update();
            }
        }

        // the first in a series of functions related to Ethnicity Modification:
        function ethnicityChangedAsian() {
            let mainSldr = document.getElementById("sldr_asian");
            let otherSldr1 = document.getElementById("sldr_african");
            let otherSldr2 = document.getElementById("sldr_caucasian");
            ethnicityChanged( mainSldr, otherSldr1, otherSldr2 );
            setEthnicityShape( mainSldr, otherSldr1 );
        }
        //
        function ethnicityChangedAfrican() {
            let otherSldr1 = document.getElementById("sldr_asian");
            let mainSldr = document.getElementById("sldr_african");
            let otherSldr2 = document.getElementById("sldr_caucasian");
            ethnicityChanged( mainSldr, otherSldr1, otherSldr2 );
            setEthnicityShape( otherSldr1, mainSldr );
        }  
        //
        function ethnicityChangedCaucasian() {
            let otherSldr1 = document.getElementById("sldr_asian");
            let otherSldr2 = document.getElementById("sldr_african");
            let mainSldr = document.getElementById("sldr_caucasian");
            ethnicityChanged( mainSldr, otherSldr1, otherSldr2 );
            setEthnicityShape( otherSldr1, otherSldr2 );
        }
        //
        // common logic for the normalization & updating of the ethnicity controls
        // when any one ethnicity range slider has been modified:
        function ethnicityChanged( mainSldr, otherSldr1, otherSldr2 ) {
            let mainValue = parseFloat(mainSldr.value);
            let other1Value = parseFloat(otherSldr1.value);
            let other2Value = parseFloat(otherSldr2.value);
            let s = mainValue + other1Value + other2Value;
            if (s != 0) {
                let d = (s - 100.0) * 0.5;
                other1Value -= d;
                other2Value -= d;
                s = mainValue + other1Value + other2Value;
                mainValue = mainValue / s * 100;
                other1Value = other1Value / s * 100;
                other2Value = other2Value / s * 100;
            }
            else {
                mainValue = 100;
                other1Value = 0;
                other2Value = 0;
            }
            mainSldr.value = mainValue;
            otherSldr1.value = other1Value;
            otherSldr2.value = other2Value;

		    gNewAvatarSceneInfo.race.asian = parseFloat(document.getElementById("sldr_asian").value) / 100.0;
		    gNewAvatarSceneInfo.race.african = parseFloat(document.getElementById("sldr_african").value) / 100.0;
		    gNewAvatarSceneInfo.race.caucasian = parseFloat(document.getElementById("sldr_caucasian").value) / 100.0;
        }
        //
        // last routine related to Ethnicity Modifications;
        // this sets the avatar face's ethnicity characteristics / shape:
        // (Note the default ethnicity is Caucasian, so the other ethnicities are expressed
        // as the percentage-wise morphs to Asian and African, morphs away from Caucasian.)
        function setEthnicityShape( asianCtrl, africanCtrl ) {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');
                let asianKey = av_body.morphTargetDictionary.FemaleAsian;
                let africanKey = av_body.morphTargetDictionary.FemaleBlack;
                av_body.morphTargetInfluences[asianKey] = parseFloat(asianCtrl.value) / 100.0;
                av_body.morphTargetInfluences[africanKey] = parseFloat(africanCtrl.value) / 100.0;
            }
        }

        function thin2HeavyChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');
                let faHeavyKey = av_body.morphTargetDictionary.fa_Heavy;
                let fbHeavyKey = av_body.morphTargetDictionary.fb_Heavy;
                let fwHeavyKey = av_body.morphTargetDictionary.fw_Heavy;
                let faSkinnyKey = av_body.morphTargetDictionary.fa_Skinny;
                let fbSkinnyKey = av_body.morphTargetDictionary.fb_Skinny;
                let fwSkinnyKey = av_body.morphTargetDictionary.fw_Skinny;

                // forcing wt to be within 0.0 to 2.0:
                let wt = parseFloat(document.getElementById("sldr_thin2Heavy").value) / 50.0;
                // check if we're making em fat:
                if (wt >= 1.0) {
                    wt -= 1.0;  // percentage they want to be fat
                    // that percentage is realized within their ethnicity:
                    av_body.morphTargetInfluences[faHeavyKey] = wt * gNewAvatarSceneInfo.race.asian;
                    av_body.morphTargetInfluences[fbHeavyKey] = wt * gNewAvatarSceneInfo.race.african;
                    av_body.morphTargetInfluences[fwHeavyKey] = wt * gNewAvatarSceneInfo.race.caucasian;
                    
                    av_body.morphTargetInfluences[faSkinnyKey] = 0.0;
                    av_body.morphTargetInfluences[fbSkinnyKey] = 0.0;
                    av_body.morphTargetInfluences[fwSkinnyKey] = 0.0;
                }
                else { // nope, we're making em skinny:
                    wt = 1.0 - wt; // percentage they want to be thin
                    // that percentage is realized within their ethnicity:
                    av_body.morphTargetInfluences[faHeavyKey] = 0.0;
                    av_body.morphTargetInfluences[fbHeavyKey] = 0.0;
                    av_body.morphTargetInfluences[fwHeavyKey] = 0.0;
                    
                    av_body.morphTargetInfluences[faSkinnyKey] = wt * gNewAvatarSceneInfo.race.asian;
                    av_body.morphTargetInfluences[fbSkinnyKey] = wt * gNewAvatarSceneInfo.race.african;
                    av_body.morphTargetInfluences[fwSkinnyKey] = wt * gNewAvatarSceneInfo.race.caucasian;
                }
            }
        }

        function muscularityChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');
                let faMuscularKey = av_body.morphTargetDictionary.fa_Muscular;
                let fbMuscularKey = av_body.morphTargetDictionary.fb_Muscular;
                let fwMuscularKey = av_body.morphTargetDictionary.fw_Muscular;
                let maMuscularKey = av_body.morphTargetDictionary.ma_Muscular;
                let mbMuscularKey = av_body.morphTargetDictionary.mb_Muscular;
                let mwMuscularKey = av_body.morphTargetDictionary.mw_Muscular;

                // forcing wt to be within 0.0 to 3.0:
                let wt = parseFloat(document.getElementById("sldr_muscularity").value) / 100.0;
                
                av_body.morphTargetInfluences[faMuscularKey] = wt * 0.3333;
                av_body.morphTargetInfluences[fbMuscularKey] = wt * 0.3333;
                av_body.morphTargetInfluences[fwMuscularKey] = wt * 0.3333;

                av_body.morphTargetInfluences[maMuscularKey] = wt * 0.16665;
                av_body.morphTargetInfluences[mbMuscularKey] = wt * 0.16665;
                av_body.morphTargetInfluences[mwMuscularKey] = wt * 0.16665;
            }
        }

        function jawInOutChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');
                let av_lowerTeeth = gScene.getObjectByName('LowerTeeth_Mesh');
                let av_lowerGums = gScene.getObjectByName('LowerTeeth_Mesh_1');

                let raceWt = [
                    gNewAvatarSceneInfo.race.asian,
                    gNewAvatarSceneInfo.race.african,
                    gNewAvatarSceneInfo.race.caucasian
                ];

                let jawOutKey = [ 
                    av_body.morphTargetDictionary.fa_JawOut,
                    av_body.morphTargetDictionary.fb_JawOut,
                    av_body.morphTargetDictionary.fw_JawOut 
                ];

                let jawInKey = [ 
                    av_body.morphTargetDictionary.fa_JawIn,
                    av_body.morphTargetDictionary.fb_JawIn,
                    av_body.morphTargetDictionary.fw_JawIn 
                ];

                // forcing wt to be within 0.0 to 2.0:
                let wt = parseFloat(document.getElementById("sldr_jawInOut").value) / 50.0;
                // check for direction:
                if (wt >= 1.0) {
                    wt -= 1.0;  // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[jawOutKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[jawInKey[i]] = 0.0;
                    }

                    av_lowerTeeth.morphTargetInfluences[ av_lowerTeeth.morphTargetDictionary.JawOut_LowerTeeth ] = wt;
                    av_lowerGums.morphTargetInfluences[ av_lowerGums.morphTargetDictionary.JawOut_LowerTeeth ] = wt;

                    av_lowerTeeth.morphTargetInfluences[ av_lowerTeeth.morphTargetDictionary.JawIn_LowerTeeth ] = 0.0;
                    av_lowerGums.morphTargetInfluences[ av_lowerGums.morphTargetDictionary.JawIn_LowerTeeth ] = 0.0;
                }
                else { 
                    wt = 1.0 - wt; // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[jawInKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[jawOutKey[i]] = 0.0;
                    }

                    av_lowerTeeth.morphTargetInfluences[ av_lowerTeeth.morphTargetDictionary.JawIn_LowerTeeth ] = wt;
                    av_lowerGums.morphTargetInfluences[ av_lowerGums.morphTargetDictionary.JawIn_LowerTeeth ] = wt;

                    av_lowerTeeth.morphTargetInfluences[ av_lowerTeeth.morphTargetDictionary.JawOut_LowerTeeth ] = 0.0;
                    av_lowerGums.morphTargetInfluences[ av_lowerGums.morphTargetDictionary.JawOut_LowerTeeth ] = 0.0;
                }
            }
        }

        function squareJawChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');

                let raceWt = [
                    gNewAvatarSceneInfo.race.asian,
                    gNewAvatarSceneInfo.race.african,
                    gNewAvatarSceneInfo.race.caucasian
                ];

                let squareJawKey = [ 
                    av_body.morphTargetDictionary.fa_SquareJaw,
                    av_body.morphTargetDictionary.fb_SquareJaw,
                    av_body.morphTargetDictionary.fw_SquareJaw 
                ];

                // forcing wt to be within 0.0 to 1.0:
                let wt = parseFloat(document.getElementById("sldr_squareJaw").value) / 100.0;
                for (let i = 0; i < 3; i++) {
                    av_body.morphTargetInfluences[squareJawKey[i]] = wt * raceWt[i];
                }
            }
        }

        function chinCleftChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');

                let raceWt = [
                    gNewAvatarSceneInfo.race.asian,
                    gNewAvatarSceneInfo.race.african,
                    gNewAvatarSceneInfo.race.caucasian
                ];

                let chinCleftKey = [ 
                    av_body.morphTargetDictionary.fa_ChinCleft,
                    av_body.morphTargetDictionary.fb_ChinCleft,
                    av_body.morphTargetDictionary.fw_ChinCleft 
                ];

                // forcing wt to be within 0.0 to 1.0:
                let wt = parseFloat(document.getElementById("sldr_chinCleft").value) / 100.0;
                for (let i = 0; i < 3; i++) {
                    av_body.morphTargetInfluences[chinCleftKey[i]] = wt * raceWt[i];
                }
            }
        }
 
        function chinInOutChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');

                let raceWt = [
                    gNewAvatarSceneInfo.race.asian,
                    gNewAvatarSceneInfo.race.african,
                    gNewAvatarSceneInfo.race.caucasian
                ];

                let chinOutKey = [ 
                    av_body.morphTargetDictionary.fa_ChinOut,
                    av_body.morphTargetDictionary.fb_ChinOut,
                    av_body.morphTargetDictionary.fw_ChinOut 
                ];

                let chinInKey = [ 
                    av_body.morphTargetDictionary.fa_ChinIn,
                    av_body.morphTargetDictionary.fb_ChinIn,
                    av_body.morphTargetDictionary.fw_ChinIn 
                ];

                // forcing wt to be within 0.0 to 2.0:
                let wt = parseFloat(document.getElementById("sldr_chinInOut").value) / 50.0;
                // check for direction:
                if (wt >= 1.0) {
                    wt -= 1.0;  // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[chinOutKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[chinInKey[i]] = 0.0;
                    }
                }
                else { 
                    wt = 1.0 - wt; // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[chinInKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[chinOutKey[i]] = 0.0;
                    }
                }
            }
        }

        function mouthInOutChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');

                let raceWt = [
                    gNewAvatarSceneInfo.race.asian,
                    gNewAvatarSceneInfo.race.african,
                    gNewAvatarSceneInfo.race.caucasian
                ];

                let mouthOutKey = [ 
                    av_body.morphTargetDictionary.fa_MouthOut,
                    av_body.morphTargetDictionary.fb_MouthOut,
                    av_body.morphTargetDictionary.fw_MouthOut 
                ];

                let mouthInKey = [ 
                    av_body.morphTargetDictionary.fa_MouthIn,
                    av_body.morphTargetDictionary.fb_MouthIn,
                    av_body.morphTargetDictionary.fw_MouthIn 
                ];

                // forcing wt to be within 0.0 to 2.0:
                let wt = parseFloat(document.getElementById("sldr_mouthInOut").value) / 50.0;
                // check for direction:
                if (wt >= 1.0) {
                    wt -= 1.0;  // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[mouthOutKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[mouthInKey[i]] = 0.0;
                    }
                }
                else { 
                    wt = 1.0 - wt; // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[mouthInKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[mouthOutKey[i]] = 0.0;
                    }
                }
            }
        }

        function mouthWidthChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');

                let raceWt = [
                    gNewAvatarSceneInfo.race.asian, gNewAvatarSceneInfo.race.asian,
                    gNewAvatarSceneInfo.race.african, gNewAvatarSceneInfo.race.african,
                    gNewAvatarSceneInfo.race.caucasian, gNewAvatarSceneInfo.race.caucasian
                ];

                let outKey = [ 
                    av_body.morphTargetDictionary.fa_WidePurseOutLeft, av_body.morphTargetDictionary.fa_WidePurseOutRight,
                    av_body.morphTargetDictionary.fb_WidePurseOutLeft, av_body.morphTargetDictionary.fb_WidePurseOutRight,
                    av_body.morphTargetDictionary.fw_WidePurseOutLeft, av_body.morphTargetDictionary.fw_WidePurseOutRight,
                ];

                let inKey = [ 
                    av_body.morphTargetDictionary.fa_WidePurseInLeft, av_body.morphTargetDictionary.fa_WidePurseInRight,
                    av_body.morphTargetDictionary.fb_WidePurseInLeft, av_body.morphTargetDictionary.fb_WidePurseInRight,
                    av_body.morphTargetDictionary.fw_WidePurseInLeft, av_body.morphTargetDictionary.fw_WidePurseInRight,
                ];

                // forcing wt to be within 0.0 to 2.0:
                let wt = parseFloat(document.getElementById("sldr_mouthWidth").value) / 50.0;
                // check for direction:
                if (wt >= 1.0) {
                    wt -= 1.0;  // percentage they want 

                    for (let i = 0; i < 6; i++) {
                        av_body.morphTargetInfluences[outKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[inKey[i]] = 0.0;
                    }
                }
                else { 
                    wt = 1.0 - wt; // percentage they want 

                    for (let i = 0; i < 6; i++) {
                        av_body.morphTargetInfluences[inKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[outKey[i]] = 0.0;
                    }
                }
            }
        }

        function gauntChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');

                let raceWt = [
                    gNewAvatarSceneInfo.race.asian,
                    gNewAvatarSceneInfo.race.african,
                    gNewAvatarSceneInfo.race.caucasian
                ];

                let gauntKey = [ 
                    av_body.morphTargetDictionary.fa_Gaunt,
                    av_body.morphTargetDictionary.fb_Gaunt,
                    av_body.morphTargetDictionary.fw_Gaunt 
                ];

                // forcing wt to be within 0.0 to 1.0:
                let wt = parseFloat(document.getElementById("sldr_gaunt").value) / 100.0;
                for (let i = 0; i < 3; i++) {
                    av_body.morphTargetInfluences[gauntKey[i]] = wt * raceWt[i];
                }
            }
        }

        function doubleChinChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');

                let raceWt = [
                    gNewAvatarSceneInfo.race.asian,
                    gNewAvatarSceneInfo.race.african,
                    gNewAvatarSceneInfo.race.caucasian
                ];

                let doubleChinKey = [ 
                    av_body.morphTargetDictionary.fa_DoubleChin,
                    av_body.morphTargetDictionary.fb_DoubleChin,
                    av_body.morphTargetDictionary.fw_DoubleChin 
                ];

                // forcing wt to be within 0.0 to 1.0:
                let wt = parseFloat(document.getElementById("sldr_doubleChin").value) / 100.0;
                for (let i = 0; i < 3; i++) {
                    av_body.morphTargetInfluences[doubleChinKey[i]] = wt * raceWt[i];
                }
            }
        }

        function cheekBonesChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');

                let raceWt = [
                    gNewAvatarSceneInfo.race.asian,
                    gNewAvatarSceneInfo.race.african,
                    gNewAvatarSceneInfo.race.caucasian
                ];

                let cheekBoneKey = [ 
                    av_body.morphTargetDictionary.fa_HighCheekBones,
                    av_body.morphTargetDictionary.fb_HighCheekBones,
                    av_body.morphTargetDictionary.fw_HighCheekBones 
                ];

                // forcing wt to be within 0.0 to 1.0:
                let wt = parseFloat(document.getElementById("sldr_cheekBones").value) / 100.0;
                for (let i = 0; i < 3; i++) {
                    av_body.morphTargetInfluences[cheekBoneKey[i]] = wt * raceWt[i];
                }
            }
        }

        function noseSizeChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');

                let raceWt = [
                    gNewAvatarSceneInfo.race.asian,
                    gNewAvatarSceneInfo.race.african,
                    gNewAvatarSceneInfo.race.caucasian
                ];

                let noseBigKey = [ 
                    av_body.morphTargetDictionary.fa_NoseLarge,
                    av_body.morphTargetDictionary.fb_NoseLarge,
                    av_body.morphTargetDictionary.fw_NoseLarge 
                ];

                let noseSmallKey = [ 
                    av_body.morphTargetDictionary.fa_NoseSmall,
                    av_body.morphTargetDictionary.fb_NoseSmall,
                    av_body.morphTargetDictionary.fw_NoseSmall
                ];

                // forcing wt to be within 0.0 to 2.0:
                let wt = parseFloat(document.getElementById("sldr_noseSize").value) / 50.0;
                // check for direction:
                if (wt >= 1.0) {
                    wt -= 1.0;  // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[noseBigKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[noseSmallKey[i]] = 0.0;
                    }
                }
                else { 
                    wt = 1.0 - wt; // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[noseSmallKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[noseBigKey[i]] = 0.0;
                    }
                }
            }
        }

        function noseTopInOutChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');

                let raceWt = [
                    gNewAvatarSceneInfo.race.asian,
                    gNewAvatarSceneInfo.race.african,
                    gNewAvatarSceneInfo.race.caucasian
                ];

                let noseHighOutKey = [ 
                    av_body.morphTargetDictionary.fa_NoseHighOut,
                    av_body.morphTargetDictionary.fb_NoseHighOut,
                    av_body.morphTargetDictionary.fw_NoseHighOut 
                ];

                let noseHighInKey = [ 
                    av_body.morphTargetDictionary.fa_NoseHighIn,
                    av_body.morphTargetDictionary.fb_NoseHighIn,
                    av_body.morphTargetDictionary.fw_NoseHighIn
                ];

                // forcing wt to be within 0.0 to 2.0:
                let wt = parseFloat(document.getElementById("sldr_noseTopInOut").value) / 50.0;
                // check for direction:
                if (wt >= 1.0) {
                    wt -= 1.0;  // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[noseHighOutKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[noseHighInKey[i]] = 0.0;
                    }
                }
                else { 
                    wt = 1.0 - wt; // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[noseHighInKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[noseHighOutKey[i]] = 0.0;
                    }
                }
            }
        }

        function noseMidInOutChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');

                let raceWt = [
                    gNewAvatarSceneInfo.race.asian,
                    gNewAvatarSceneInfo.race.african,
                    gNewAvatarSceneInfo.race.caucasian
                ];

                let noseMidOutKey = [ 
                    av_body.morphTargetDictionary.fa_NoseMidOut,
                    av_body.morphTargetDictionary.fb_NoseMidOut,
                    av_body.morphTargetDictionary.fw_NoseMidOut 
                ];

                let noseMidInKey = [ 
                    av_body.morphTargetDictionary.fa_NoseMidIn,
                    av_body.morphTargetDictionary.fb_NoseMidIn,
                    av_body.morphTargetDictionary.fw_NoseMidIn
                ];

                // forcing wt to be within 0.0 to 2.0:
                let wt = parseFloat(document.getElementById("sldr_noseMidInOut").value) / 50.0;
                // check for direction:
                if (wt >= 1.0) {
                    wt -= 1.0;  // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[noseMidOutKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[noseMidInKey[i]] = 0.0;
                    }
                }
                else { 
                    wt = 1.0 - wt; // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[noseMidInKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[noseMidOutKey[i]] = 0.0;
                    }
                }
            }
        }

        function noseTipChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');

                let raceWt = [
                    gNewAvatarSceneInfo.race.asian,
                    gNewAvatarSceneInfo.race.african,
                    gNewAvatarSceneInfo.race.caucasian
                ];

                let noseTipKey = [ 
                    av_body.morphTargetDictionary.fa_NoseTipOut,
                    av_body.morphTargetDictionary.fb_NoseTipOut,
                    av_body.morphTargetDictionary.fw_NoseTipOut 
                ];

                // forcing wt to be within 0.0 to 1.0:
                let wt = parseFloat(document.getElementById("sldr_noseTip").value) / 100.0;
                for (let i = 0; i < 3; i++) {
                    av_body.morphTargetInfluences[noseTipKey[i]] = wt * raceWt[i];
                }
            }
        }

        function browInOutChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');

                let raceWt = [
                    gNewAvatarSceneInfo.race.asian,
                    gNewAvatarSceneInfo.race.african,
                    gNewAvatarSceneInfo.race.caucasian
                ];

                let browOutKey = [ 
                    av_body.morphTargetDictionary.fa_BrowOut,
                    av_body.morphTargetDictionary.fb_BrowOut,
                    av_body.morphTargetDictionary.fw_BrowOut 
                ];

                let browInKey = [ 
                    av_body.morphTargetDictionary.fa_BrowFaceIn,
                    av_body.morphTargetDictionary.fb_BrowFaceIn,
                    av_body.morphTargetDictionary.fw_BrowFaceIn
                ];

                // forcing wt to be within 0.0 to 2.0:
                let wt = parseFloat(document.getElementById("sldr_browInOut").value) / 50.0;
                // check for direction:
                if (wt >= 1.0) {
                    wt -= 1.0;  // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[browOutKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[browInKey[i]] = 0.0;
                    }
                }
                else { 
                    wt = 1.0 - wt; // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[browInKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[browOutKey[i]] = 0.0;
                    }
                }
            }
        }

        function foreheadTopChanged() {
            if (gNewAvatarSceneInfo.inited) {
                let av_body = gScene.getObjectByName('av_FemaleAvatar');

                let raceWt = [
                    gNewAvatarSceneInfo.race.asian,
                    gNewAvatarSceneInfo.race.african,
                    gNewAvatarSceneInfo.race.caucasian
                ];

                let foreheadTopOutKey = [ 
                    av_body.morphTargetDictionary.fa_ForeHeadTopOut,
                    av_body.morphTargetDictionary.fb_ForeHeadTopOut,
                    av_body.morphTargetDictionary.fw_ForeHeadTopOut 
                ];

                let foreheadTopInKey = [ 
                    av_body.morphTargetDictionary.fa_ForeHeadTopIn,
                    av_body.morphTargetDictionary.fb_ForeHeadTopIn,
                    av_body.morphTargetDictionary.fw_ForeHeadTopIn
                ];

                // forcing wt to be within 0.0 to 2.0:
                let wt = parseFloat(document.getElementById("sldr_foreheadTop").value) / 50.0;
                // check for direction:
                if (wt >= 1.0) {
                    wt -= 1.0;  // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[foreheadTopOutKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[foreheadTopInKey[i]] = 0.0;
                    }
                }
                else { 
                    wt = 1.0 - wt; // percentage they want 

                    for (let i = 0; i < 3; i++) {
                        av_body.morphTargetInfluences[foreheadTopInKey[i]] = wt * raceWt[i];
                        av_body.morphTargetInfluences[foreheadTopOutKey[i]] = 0.0;
                    }
                }
            }
        }

        function resetFaceShape() {
            if (gNewAvatarSceneInfo.inited) {
                document.getElementById("sldr_jawInOut").value = "50";
                document.getElementById("sldr_squareJaw").value = "0";
                document.getElementById("sldr_chinCleft").value = "0";
                document.getElementById("sldr_chinInOut").value = "50";
                document.getElementById("sldr_mouthInOut").value = "50";
                document.getElementById("sldr_mouthWidth").value = "50";
                document.getElementById("sldr_gaunt").value = "0";
                document.getElementById("sldr_doubleChin").value = "0";
                document.getElementById("sldr_cheekBones").value = "0";
                document.getElementById("sldr_noseSize").value = "50";
                document.getElementById("sldr_noseTopInOut").value = "50";
                document.getElementById("sldr_noseMidInOut").value = "50";
                document.getElementById("sldr_noseTip").value = "0";
                document.getElementById("sldr_browInOut").value = "50";
                document.getElementById("sldr_foreheadTop").value = "50";
                jawInOutChanged();
                squareJawChanged();
                chinCleftChanged();
                chinInOutChanged();
                mouthInOutChanged();
                mouthWidthChanged();
                gauntChanged();
                doubleChinChanged();
                cheekBonesChanged();
                noseSizeChanged();
                noseTopInOutChanged();
                noseMidInOutChanged();
                noseTipChanged();
                browInOutChanged();
                foreheadTopChanged();
            }
        }

    </script>

	<script src="/static/stats.js/build/stats.min.js"></script>

	<script type="module">

		document.addEventListener("DOMContentLoaded", function() {
			page_init();
			DoThree( gNewAvatarSceneInfo );
		  },{ once: true });


		import {
			PerspectiveCamera, CameraHelper,
			Scene, Color, Fog, HemisphereLight, DirectionalLight,
			BoxGeometry, PlaneGeometry,
			MeshNormalMaterial,
			MeshStandardMaterial, MeshPhongMaterial, MeshBasicMaterial,
			Mesh, AnimationMixer, GridHelper, Object3D,
			WebGLRenderer,
			Clock, MathUtils
		} from 'three';

		import { OrbitControls } from '/static/three/examples/jsm/controls/OrbitControls.js';
		import { DRACOLoader } from '/static/three/examples/jsm/loaders/DRACOLoader.js';
		import { GLTFLoader } from '/static/three/examples/jsm/loaders/GLTFLoader.js';


		// dumps a gltf scene graph
		function dumpObject(obj, lines = [], isLast = true, prefix = '') {
			const localPrefix = isLast ? '└─' : '├─';
			lines.push(`${prefix}${prefix ? localPrefix : ''}${obj.name || '*no-name*'} [${obj.type}]`);
			const newPrefix = prefix + (isLast ? '  ' : '│ ');
			const lastNdx = obj.children.length - 1;
			obj.children.forEach((child, ndx) => {
			  const isLast = ndx === lastNdx;
			  dumpObject(child, lines, isLast, newPrefix);
			});
			return lines;
		}

		// collects the mesh objects, placing them into 'meshObjs[]':
		function getMeshObjects(obj, meshObjs = [], isLast = true) {
			if (obj.type=='Mesh')
				meshObjs.push(obj);
			//
			const lastNdx = obj.children.length - 1;
			obj.children.forEach((child, ndx) => {
			  const isLast = ndx === lastNdx;
			  getMeshObjects(child, meshObjs, isLast);
			});
			return meshObjs;
		}
	

        function removeObject3D(object3D) {
            if (!(object3D instanceof Object3D)) return false;
        
            // for better memory management and performance
            if (object3D.geometry) object3D.geometry.dispose();
        
            if (object3D.material) {
                if (object3D.material instanceof Array) {
                    // for better memory management and performance
                    object3D.material.forEach(material => material.dispose());
                } else {
                    // for better memory management and performance
                    object3D.material.dispose();
                }
            }
            object3D.removeFromParent(); // the parent might be the scene or another Object3D, but it is sure to be removed this way
            return true;
        }

		function DoThree( sceneInfo  ) {

			let renderer, stats;

			const clock = new Clock();
	
			DoThreeInit( sceneInfo );
			animate();
	
			function DoThreeInit( sceneInfo ) {
	
				const container = document.createElement( 'div' );
				//
				let mainTag = document.getElementById("mainContent")
				mainTag.appendChild( container );
	
				gCamera = new PerspectiveCamera( 45, mainTag.offsetWidth / mainTag.offsetHeight, 1, 2000 );
                // now set by viewAtLoad();
				// gCamera.position.set( sceneInfo.cam.pos.x, sceneInfo.cam.pos.y, sceneInfo.cam.pos.z );

				gScene = new Scene();
				gScene.background = new Color( 0xa0a0a0 );
				gScene.fog = new Fog( 0xa0a0a0, 200, 1000 );
	
				const hemiLight = new HemisphereLight( 0xffffff, 0x444444 );
				hemiLight.position.set( 0, 200, 300 );
				gScene.add( hemiLight );
	

				const dirLight = new DirectionalLight( 0xcccccc );
				dirLight.position.set( 70, 50, 100 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.top = 40;
				dirLight.shadow.camera.bottom = - 20;
				dirLight.shadow.camera.left = - 20;
				dirLight.shadow.camera.right = 20;
				gScene.add( dirLight );
	
				if (sceneInfo.cam.helper)
					gScene.add( new CameraHelper( dirLight.shadow.camera ) );
	
                    
				const dirLight2 = new DirectionalLight( 0xaaaaaa );
				dirLight2.position.set( -70, 50, -100 );
				dirLight2.castShadow = true;
				dirLight2.shadow.camera.top = 40;
				dirLight2.shadow.camera.bottom = - 20;
				dirLight2.shadow.camera.left = - 20;
				dirLight2.shadow.camera.right = 20;
				gScene.add( dirLight2 );
	
				if (sceneInfo.cam.helper)
					gScene.add( new CameraHelper( dirLight2.shadow.camera ) );
	

				// ground
				const mesh = new Mesh( new PlaneGeometry( 2000, 2000 ), new MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
				mesh.rotation.x = - Math.PI / 2;
				mesh.receiveShadow = true;
				gScene.add( mesh );
	
				const grid = new GridHelper( 2000, 20, 0x000000, 0x000000 );
				grid.material.opacity = 0.2;
				grid.material.transparent = true;
				gScene.add( grid );
	

                const geometry = new BoxGeometry( 50, 2, 2 ); // width, height, depth
                const material = new MeshBasicMaterial( { color: 0x00ff00, transparent: true, opacity: 0.5 } );
                gProgressCube = new Mesh( geometry, material );
                gProgressCube.position.set( 0, 15, 0 );
                gScene.add( gProgressCube );

				// Instantiate a loader
				const loader = new GLTFLoader();
				//
				let loadProgFract = 0;
				let loadProgress = loadProgFract;
				let lastLoadProgress = loadProgress;

				// Optional: Provide a DRACOLoader instance to decode compressed mesh data
				const dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath( '/static/three/examples/js/libs/draco/' );
				loader.setDRACOLoader( dracoLoader ); /**/

				// Load a glTF resource
				loader.load(
					sceneInfo.obj.url,
					// called when the resource is loaded
					function ( gltf ) {

                        gProgressCube.material.opacity = 0.5;

						gParentObj = gltf.scene;
						gParentObj.scale.set( sceneInfo.obj.scale, sceneInfo.obj.scale, sceneInfo.obj.scale );

						console.log(dumpObject(gParentObj).join('\n'));

						getMeshObjects(gParentObj, gMeshObjs);
						let count = gMeshObjs.length;
						for (let i = 0; i < count; i++) {
							console.log("gMeshObjs[" + i + "] has name " + gMeshObjs[i].name);
							gMeshObjs[i].castShadow = true;
							gMeshObjs[i].receiveShadow  = false;
						}

				/*		gltf.parser.getDependencies( 'material' ).then( ( materials ) => {

							console.log( materials );
						
						} ); /* */
			
						gScene.add(gParentObj);
                        removeObject3D(gProgressCube)

                        gNewAvatarSceneInfo.inited = true;
					},
					// called while loading is progressing
					function ( xhr ) {

                        loadProgFract = xhr.loaded / xhr.total;

                        gProgressCube.scale.set( loadProgFract, 1, 1 );
                        gProgressCube.material.opacity = loadProgFract;
                        
						loadProgress = loadProgFract * 100;
						if (loadProgress <= lastLoadProgress + 10)
							return;
						
						console.log( loadProgress + '% loaded' );

						lastLoadProgress += 10;

					},
					// called when loading has errors
					function ( error ) {

						console.log( 'An error happened' );

					}
				);
	
				renderer = new WebGLRenderer( { antialias: true } );

				renderer.shadowMap.enabled = true;

				renderer.setPixelRatio( window.devicePixelRatio );

				renderer.setSize( mainTag.clientWidth, mainTag.clientHeight );

				container.appendChild( renderer.domElement );
	
				
				gCamCtrls = new OrbitControls( gCamera, renderer.domElement );
				// now set by viewAtLoad();
				// gCamCtrls.target.set( sceneInfo.cam.target.x, sceneInfo.cam.target.y, sceneInfo.cam.target.z );
				// gCamCtrls.update(); /**/
                viewAtLoad();

				window.addEventListener( 'resize', onWindowResize );
	
				// stats
				stats = new Stats();
				container.appendChild( stats.dom );
			}
	
			function onWindowResize() {
	
				let mainTag = document.getElementById("mainContent")
				
				gCamera.aspect = mainTag.clientWidth / mainTag.clientHeight;

				gCamera.updateProjectionMatrix();
	
				renderer.setSize( mainTag.clientWidth, mainTag.clientHeight );
			}
	
			function animate() {
	
				requestAnimationFrame( animate );
				
				const delta = clock.getDelta();
	
				renderer.render( gScene, gCamera );
	
				stats.update();
			}
		}



        
		function page_init() {
            let initialized = false;
			const access_token = localStorage.getItem('token');
			if (typeof access_token !== 'undefined') {
				const options = { headers: { "Authorization": "Bearer " + access_token } }
				fetch("/users/me", options)
				.then(response => response.json())
				.then( response => {

					if (response.hasOwnProperty('roles')) {

						// user is logged in:
						document.getElementsByTagName("nav")[0].innerHTML += 
							'<br/><br/><a href="#" class="button" onclick="UserContact()">Contact</a>';

						if (response.roles.includes("admin")) {

							document.getElementById("aside").innerHTML = 
								`<a href="#" class="button" onclick="UserSettings()">Settings</a>
								<br/><br/>
								<a href="#" class="button" onclick="Logout()">Logout</a>
								`;
						}

						initialized = true;
					}
				});
			}
			
            if (!initialized) {
				// user is not logged in:
				document.getElementsByTagName("nav")[0].innerHTML += 
				'<br/><br/><a href="#" class="button" onclick="Contact()">Contact</a>';

                initialized = true;
			}
		}

	</script>
	
	{% include 'common_logout.html' %}

	{% include 'common_refresh.html' %}
	
</body>
</html>
