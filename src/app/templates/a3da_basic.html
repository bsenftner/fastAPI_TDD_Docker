<!DOCTYPE html>
{# 
	This is a Jinja2 template for an html page
	These lines are comments and are removed when the template is rendered. 
#}
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Blog of Blake Senftner</title>
  <link rel="stylesheet" href="/static/index.css">

  <style>
   div#mainContent {
	  box-sizing: border-box;
	  font-family: Helvetica, Arial, sans-serif;
	  font-size: 16px;
	  height: 100%;
	  margin: 0px;
	  position: relative;
	}
  </style>

  <!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
  {
    "imports": {
      "three": "/static/three/build/three.module.js"
    }
  }
</script>

</head>
<body>
	<div class="grid">
		{% include 'common_header.html' %}

		{# the left sidebar #}
		{% include 'common_lsidebar.html' %}

		{# the main content area #}
		<main>
			<div id="mainContent">
				
			</div>
		</main>

		{# the right sidebar #}
		<aside>
			<div id="aside">
				<a href="#" class="button" onclick="Login()">Login</a>
				<br/>
				<a href="#" class="button" onclick="Register()">Register</a>
			</div>
		</aside>
  
	<footer>
		{{ frags[0].footer | safe }} 
	</footer>
	</div>

	
	<script src="/static/stats.js/build/stats.min.js"></script>

	<script type="module">

		// import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

		document.addEventListener("DOMContentLoaded", function() {
			page_init();
			DoThree();
		  });
		function page_init() {
			const access_token = localStorage.getItem('token');
			if (access_token) {
				const options = { headers: { "Authorization": "Bearer " + access_token } }
				fetch("/users/me", options)
				.then(response => response.json())
				.then( response => 
					{
						console.log(response)
						if (response.hasOwnProperty('roles')) {

							// user is at least logged in 
							document.getElementsByTagName("nav")[0].innerHTML += 
							'<br/><br/><a href="#" class="button" onclick="UserContact()">Contact</a>';

							if (response.roles.includes("admin")) {

								document.getElementById("aside").innerHTML = 
								`<a href="#" class="button" onclick="UserSettings()">Settings</a>
								<br/><br/>
								<a href="#" class="button" onclick="Logout()">Logout</a>
								`;
							}

						}
				  })
			}
			else {
				// user is not logged in 
				document.getElementsByTagName("nav")[0].innerHTML += 
				'<br/><br/><a href="#" class="button" onclick="Contact()">Contact</a>';
			}
		}

		function UserContact() { window.location.href = "/Contact"; }

		function Contact() { window.location.href = "/precontact"; }

		function Login() { window.location.href = "/login"; }

		function Register() { window.location.href = "/register"; }

		function UserSettings() { window.location.href = "/Settings"; }

		import {
			PerspectiveCamera, // CameraHelper,
			Scene, Color, Fog, HemisphereLight, DirectionalLight,
			BoxGeometry, PlaneGeometry,
			MeshNormalMaterial,
			MeshStandardMaterial, MeshPhongMaterial,
			Mesh, GridHelper,
			WebGLRenderer,
			Clock
		} from 'three';

		import { OrbitControls } from '/static/three/examples/jsm/controls/OrbitControls.js';
		import { DRACOLoader } from '/static/three/examples/jsm/loaders/DRACOLoader.js';
		import { GLTFLoader } from '/static/three/examples/jsm/loaders/GLTFLoader.js';

		function DoThree2() {
			// init
			const container = document.createElement( 'div' );
			//
			let mainTag = document.getElementById("mainContent")
			mainTag.appendChild( container );

			const camera = new PerspectiveCamera( 70, mainTag.offsetWidth / mainTag.offsetHeight, 0.01, 10 );
			camera.position.z = 1;

			const scene = new Scene();

			const geometry = new BoxGeometry( 0.2, 0.2, 0.2 );
			const material = new MeshNormalMaterial();

			const mesh = new Mesh( geometry, material );
			scene.add( mesh );

			const renderer = new WebGLRenderer( { antialias: true } );

			renderer.setSize( mainTag.offsetWidth, mainTag.offsetHeight );
			renderer.setAnimationLoop( animation );
			
			container.appendChild( renderer.domElement );
			window.addEventListener( 'resize', onWindResize );

			// animation
			function animation( time ) {

				mesh.rotation.x = time / 2000;
				mesh.rotation.y = time / 1000;

				renderer.render( scene, camera );
			}

			function onWindResize() {

				let mainTag = document.getElementById("mainContent")
				
				camera.aspect = mainTag.offsetWidth / mainTag.offsetHeight;

				camera.updateProjectionMatrix();
	

				// renderer.setSize( mainTag.innerWidth, mainTag.innerHeight );
				renderer.setSize( mainTag.offsetWidth, mainTag.offsetHeight );
			}
		}

		// dumps a gltf scene graph
		function dumpObject(obj, lines = [], isLast = true, prefix = '') {
			const localPrefix = isLast ? '└─' : '├─';
			lines.push(`${prefix}${prefix ? localPrefix : ''}${obj.name || '*no-name*'} [${obj.type}]`);
			const newPrefix = prefix + (isLast ? '  ' : '│ ');
			const lastNdx = obj.children.length - 1;
			obj.children.forEach((child, ndx) => {
			  const isLast = ndx === lastNdx;
			  dumpObject(child, lines, isLast, newPrefix);
			});
			return lines;
		}

		function DoThree() {

			let camera, scene, renderer, stats;

			const clock = new Clock();
	
			let mixer;
	
			init();
			animate();
	
			function init() {
	
				const container = document.createElement( 'div' );
				//
				let mainTag = document.getElementById("mainContent")
				mainTag.appendChild( container );
	
				camera = new PerspectiveCamera( 45, mainTag.offsetWidth / mainTag.offsetHeight, 1, 2000 );
				camera.position.set( 100, 200, 300 );
	
				scene = new Scene();
				scene.background = new Color( 0xa0a0a0 );
				scene.fog = new Fog( 0xa0a0a0, 200, 1000 );
	
				const hemiLight = new HemisphereLight( 0xffffff, 0x444444 );
				hemiLight.position.set( 0, 200, 0 );
				scene.add( hemiLight );
	
				const dirLight = new DirectionalLight( 0xffffff );
				dirLight.position.set( 0, 150, 500 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.top = 180;
				dirLight.shadow.camera.bottom = - 100;
				dirLight.shadow.camera.left = - 120;
				dirLight.shadow.camera.right = 120;
				scene.add( dirLight );
	
				// scene.add( new CameraHelper( dirLight.shadow.camera ) );
	
				// ground
				const mesh = new Mesh( new PlaneGeometry( 2000, 2000 ), new MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
				mesh.rotation.x = - Math.PI / 2;
				mesh.receiveShadow = true;
				scene.add( mesh );
	
				const grid = new GridHelper( 2000, 20, 0x000000, 0x000000 );
				grid.material.opacity = 0.2;
				grid.material.transparent = true;
				scene.add( grid );
	


				// Instantiate a loader
				const loader = new GLTFLoader();

				// Optional: Provide a DRACOLoader instance to decode compressed mesh data
				const dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath( '/static/three/examples/js/libs/draco/' );
				loader.setDRACOLoader( dracoLoader ); /**/

				// Load a glTF resource
				loader.load(
					// resource URL
					'static/a3da/newObama2.glb',
					// called when the resource is loaded
					function ( gltf ) {

						const root = gltf.scene;
						console.log(dumpObject(root).join('\n'));

						gltf.parser.getDependencies( 'material' ).then( ( materials ) => {

							console.log( materials );
						
						} );

						scene.add(root);
						/*
						gltf.animations; // Array<THREE.AnimationClip>
						gltf.scene; // THREE.Group
						gltf.scenes; // Array<THREE.Group>
						gltf.cameras; // Array<THREE.Camera>
						gltf.asset; // Object
							*/
					},
					// called while loading is progressing
					function ( xhr ) {

						console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

					},
					// called when loading has errors
					function ( error ) {

						console.log( 'An error happened' );

					}
				);


				/*
				const geometry = new BoxGeometry( 50.0, 50.0, 50.0 );
				const material = new MeshNormalMaterial();

				const boxMesh = new Mesh( geometry, material );
				scene.add( boxMesh ); /* */


	
				renderer = new WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );

				// renderer.setSize( mainTag.offsetWidth, mainTag.offsetHeight );
				renderer.setSize( mainTag.clientWidth, mainTag.clientHeight );

				renderer.shadowMap.enabled = true;
				container.appendChild( renderer.domElement );
	
				
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 100, 0 );
				controls.update(); /**/
	
				window.addEventListener( 'resize', onWindowResize );
	
				// stats
				stats = new Stats();
				container.appendChild( stats.dom );
	
			}
	
			function onWindowResize() {
	
				let mainTag = document.getElementById("mainContent")
				
				// camera.aspect = mainTag.offsetWidth / mainTag.offsetHeight;
				camera.aspect = mainTag.clientWidth / mainTag.clientHeight;

				camera.updateProjectionMatrix();
	
				console.log( "mainTag.offsetWidth is " + mainTag.offsetWidth)
				console.log( "mainTag.offsetHeight is " + mainTag.offsetHeight)

				// renderer.setSize( mainTag.offsetWidth, mainTag.offsetHeight );
				renderer.setSize( mainTag.clientWidth, mainTag.clientHeight );
			}
	
			function animate() {
	
				requestAnimationFrame( animate );
	
				const delta = clock.getDelta();
	
				if ( mixer ) mixer.update( delta );
	
				renderer.render( scene, camera );
	
				stats.update();
	
			}
		}

	</script>
	


	{% include 'common_logout.html' %}

	{% include 'common_refresh.html' %}
	
</body>
</html>
